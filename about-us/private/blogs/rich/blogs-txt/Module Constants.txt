<p>It has been two weeks since I despaired in <a href="https://www.availlang.org/content/jumping-back">my blog about my broken toe and my coder's block</a>.  Unfortunately the toe is still broken (a condition I'm all too aware of on these icy roads...but then I guess that hasn't stopped me from going sledding, which it might have been a good idea to avoid such an activity as I now have a nice long cut on my nose).  Fortunately, however, the coder's block is gone.  Since my last blog post I have actually been filling most of my free time with the Stacks project in Avail.  I just hadn't wanted to stop long enough to talk about my progress in my blog.  I know I know, shame on me.  The purpose of this blog is to discuss my progress in my projects and to provide insight into the Avail language.  If I'm making progress and I'm not blogging about it, I'm failing in the primary purposes of this blog.  But I am here now to make up for my lack of activity!</p>

<p>I'm close to completing the lexer (tokenizing the *.avail file's comments) for Stacks.  For the lexer I have taken a two pass approach to tokenizing the comments.  On the first pass, the characters from the file (an iterator on the stacks scanner object) are read until the correct condition is met for the existence of a comment.  If the comment is a regular comment, the comment is read till the end (including nested comments), then the contents of that comment are discarded (non-comment characters are discarded as well).  If the conditions are met for it to be a Stacks comment (method comment, type comment, etc), then the comment is read to the end (including nested comments). The contents of the newly collected comment are passed over a second time which tokenizes the comment according to the grammer associated with tokenization of the characters.  Once I've finished with that, I can move onto the parser where I will employ the stacks token grammar to create actual stacks comment objects.  From there, I will then work on generating HTML around those objects.</p>

<p>There is way more on the Stacks project and it begs for more than just a paragraph, but right now there are a few outstanding things I'd like to tie off on the lexer before I give it a proper treatment in a blog (I have 3 things in the queue for debugging).  So you'll have to take my word for now that progress is being made and that I will talk about it very soon.</p>

<p>Since I'm not going to talk about Stacks this blog post, I'll discuss something I learned a little more about today, module constants.  If you are unaware of the syntactical difference between a constant and a variable, a variable declares a type when it is created, a constant does not.  For example, this is a variable:
<code>myVariable : integer := 5;</code>
where as this is a constant:
<code>myConstant ::= 5;</code>
The differences aren't just skin deep, there is actually a huge difference under the hood, especially when it comes to module constants and module variables.  Module constants are run and cached for use in subsequent runs (the same cached constants are used each time that module is run.)  The constant doesn't change until there is a complete re-compile of that module (aka, the cache is cleared).  Module variables are updated each time the module is run regardless if there has been a change to that module.</p>

<p>You might be asking yourself why is this difference notable.  So here is a quick aside regarding the modularity of Avail.  First off, Avail is a modular language.  Each module comprises bits of code that can either be made publicly available (or not).  However, in order to have access to the public methods and classes from the module, "Tuples" in a module you are creating, you must import the Tuples module in the <b>Extends</b> or <b>Uses</b> section of your module.  This feature makes it very easy for churning out DSL's and creating sandboxes with very well defined limitations...but more on that another time.   (Now there is plenty of functionality in the standard Avail library that doesn't require that you import every module, so no need to import hundreds of modules.)  So you develop your programs in module(s) which will have some order of dependency.</p>

<p>Ok, back to constants and variables.  Lets say you have two modules: Module A and Module B.  Module A uses the standard Avail library, while Module B uses Module A.  If I have a module constant in Module B, it will not be recalculated on subsequent runs if I make updates to Module A.  For example, take this bit of code from a module that I'm using to test the Stacks lexer:
<div class="restricted-width-container">
<div class="good-code-block">
it : iterator of character := an iterator over test;
scanner : stacks scanner := a stacks scanner with it;
Obtain Stacks comments from scanner;
Print: format "scanner's comments[1]=“①”\n\n" with scanner's comments[1];
q : string := concatenate scanner's comments[1] separated by "_";
Print: q;
</div></div>
This bit of code simply applies the lexer to the test file ("test") and prints out all the tokens' lexemes from the first stacks comment captured.  Note the last line before the print statement is a modular variable.  
<code>q : string := concatenate scanner's comments[1] separated by "_";</code>
It creates a string variable and applies the method, <code>"concatenate_separated by_"</code> to the first capture comment in the scanner.  This method is defined in the module, Stacks Scanner, which is being used by my test module.  As this is a variable, this method will be calculated on each run of the module regardless of changes to the module.  It is important to note that changes to the method, <code>"concatenate_separated by_"</code> will be reflected in q on each run.</p>  
<p>What would happen if this line of code were changed so that q became a module constant?  
<code>q ::= concatenate scanner's comments[1] separated by "_";</code>
The behavior would be much different in the running of this module.  On the first run, q will reflect a value that is specific to the outcome of the method, <code>"concatenate_separated by_"</code>, specific to the version of that method on the first run of q.  If you were to change the method, <code>"concatenate_separated by_"</code>, any subsequent run of the test module would not include an updated value for q.  The value of q will remain the constant that was determined upon its initial run with the verision of <code>"concatenate_separated by_"</code> used at that time.  Setting up my test module in this manner would ensure that I would not be able to see any of the changes in q reflecting changes made to my code in other modules that impact the functionality of  <code>"concatenate_separated by_"</code>.  So if I had done this and I had hair to pull out, I'd be pulling out all my hair in frustration over why the results of q aren't changing with my code updates.</p>

<p>So, moral of the story:  If you decide to use a module constant over a module variable, you must be absolutely certain that the value of your constant is not subject to change as you make changes to the surrounding modules.</p>