<p>In the past few months I have been undertaking the feat of becoming a more knowledgable programmer.  Scratch that, let's just say I have been trying to <em>become</em> a programmer; preferably one that is knowledgable about the domain as a whole.  To achieve this goal I have been doing a lot of reading and research.  The more I learn, the more doors open leading to more questions.  These new questions lead to more reading and more research, which of course leads to more questions (it has been rather invigorating as I haven't been this cerebrally active since grad school).  I've tried my best to catalog this academic journey on this blog.  The posts have been an evolution in writing style as well as technical content.  From that sentence if you understood my meaning to be <em>"some posts have been good and some have sort of sucked"</em>, then you've drawn the right conclusion.</p>

<p>My goal, of course, is not to waste your time with pointless garbage, but to compose good posts that are worth reading.  Because of that, I'd like to address something common to all of my posts that has been nagging at me: <em>I have written them with the one very large assumption that all my readers know what a type is</em>.  While perusing the Avail website, if you find that you are often asking yourself, <em>"What is a <a href="/content/types">type</a>?"</em>,  then this is the blog post for you!</p>

<p>So what is it that I hope to achieve in this blog?  Well, I don't think it is a good idea for me to go into a formal exhaustive discussion of <a class="offsite" href="https://en.wikipedia.org/wiki/Type_theory">type theory</a>.  In fact, that is exactly what I intend not to do.  It is my goal to provide you with what I believe to be the basic understanding of types that will allow you to not only understand my blogs past and future, but also to go off and comfortably compose your own programs. So in this post I will go over a few things that I believe are important to this topic.</p>

<p>In order to program Avail (or mostly any other languages for that matter), you should have:
<ol>
<li><em>some idea of what a type is</em></li>
<li><em>some grasp on how types interact</em></li>
</ol></p>

<p>You might have picked up on how I slyly put a link to a somewhat basic academic description of Avail types in the question, <em>"What is a type?"</em>, posed above.  I did this to give you a starting point to work from as I do not intend to fully reinvent the wheel.  In fact, I will link to other sources throughout this blog to help provide background on the discussion.  So if you are unfamiliar with types, you should consider reading <a href="/content/types">this</a> before continuing on with this post.  It's ok, go ahead and read it, I'll wait.</p>

<p>Finished?  Good. If you read the the section on types linked in the previous paragraph, then you should at least know at a high level, that a type is a description of a common group of things.  Number one:  <em>check</em>.</p>

<p>Now for number 2.  The good news is that if you have a basic understanding of <a class="offsite" href="https://en.wikipedia.org/wiki/Set_theory">set theory</a>, then you are pretty much in a good place to understand how types interact.  To be honest, the level at which <a class="offsite" href="https://en.wikipedia.org/wiki/Set_(mathematics)">sets</a> approximates types is all you really need to know in order to program.  And believe me, what you need to know about sets and types isn't much.  If you don't know what a set is, I encourage you to go <a class="offsite" href="https://www.mathsisfun.com/sets/sets-introduction.html">here</a> and read a little.  It will quickly become evident what a set is by reading this introduction.  If you can read and understand the whole thing, great!  Again, I'll wait until you've finished reading before proceeding.</p>

<p>Ok, got it?  Good.  <em>Incidentally, Avail does have a type called <a href="/content/types-set">set</a> which you can read all about (though, I'd do that later).</em></p>

<p>Now that you know what a set is, there are two very important set operations that you should know about: <a class="offsite" href="https://en.wikipedia.org/wiki/Set_(mathematics)#Unions" title="Given two sets A and B, the union of A and B is the set that contains all of the elements present in A as well as all of the elements present in B">union</a> denoted by <code>∪</code>, and <a class="offsite" href="https://en.wikipedia.org/wiki/Set_(mathematics)#Intersections" title="Given two sets A and B, the intersection of A and B is the set that contains only the elements that are common to both A and B">intersection</a>, denoted by <code>∩</code>.  If you are unfamiliar with these operations, read the hover text and/or go to the links provided to gain a better understanding of these operations.  As you will soon see, these operations are also applicable to types.</p>

<p>So, how exactly is a type like a set?  <b>Membership</b>.  Things belong to types in the same way that things belong to sets.  Sets have a collection of distinct elements that are <em>members</em> of the set.  Similarly, types have a collection of distinct <em><b>instances</b></em>.  An <b>instance</b> is a member of a type that represents some concrete implementation or value described by the type.  For example, the number 1 is a concrete value that is an instance of the type, <code>natural number</code>.  Natural numbers describe positive numbers; numbers that have some value greater than zero.  The number 1 fits that definition, hence it is an instance of <code>natural number</code>.  It is important to note that the number 1 belongs to more than just the type, <code>natural number</code>.  It is also an instance of <code>integer</code>, <code>whole number</code>, and <code>odd number</code> just to name a few (in fact, it is an instance of infinitely many other types, but we'll talk about that when we get into the Avail type system).</p>

<p>Because sets and types are similar along the axis of membership, the operations of <em><b>union</b></em> and <em><b>intersection</b></em> as defined on sets can also be applied to types.  The avail library has two nifty methods that do just that, <code>"_∪_"</code> and <code>"_∩_"</code>.  An example use of union would be the creation of the type <code>integer</code> from the three types: <code>negative integer</code>, <code>positive integer</code>, and <code>0's type</code> (a type whose sole instance is the number 0).
<div class="restricted-width-container">
<div class="good-code-block">negative integer ∪ 0's type ∪ positive integer = integer</div></div>
This operation is called <b>type union</b>.  We can also create a new type by finding the intersection of types.  If you had the intersection of the two types, <code>prime number</code> and <code>even number</code>,
<div class="restricted-width-container">
<div class="good-code-block">even number ∩ prime number = 2's type</div></div>
the resulting type would be <code>2's type</code> as 2 is the only number that is both even and prime.  This operation is called <b>type intersection</b>. </p>

<p>Just like with sets, you can take "subsets" of types.  A <b><a id="subtype">subtype</a></b> relates to a type in the same way a subset relates to a set.  You can take some instances from a type to create a subtype.  For example, you can take from the type <code>integer</code> all negative integers to create a new type, <code>negative integer</code>.  Because all instances of <code>negative integer</code> are also present as instances of the type <code>integer</code>, then you can say that <code>negative integer</code> is a subtype of <code>integer</code>:
<div class="restricted-width-container">
<div class="good-code-block">negative integer ⊆ integer</div></div>
To describe the relationship from the other direction, you would say that <code>integer</code> is a <em><b><a id="supertype">supertype</a></b></em> of <code>negative integer</code> (all of the instances of <code>negative integer</code> can be found in <code>integer</code>).  A <b>supertype</b>, <code>S</code>, of a type, <code>T</code>, is itself a type that contains at least all of the instances found in the type <code>T</code>.  As you might have guessed, we do have a method that tests to see if one type is the subtype of another, <code title="Is the first argument a subtype of the second argument? This does not implement the proper subtype relation, so the first argument is considered a subtype of the second argument also true if it is equal to the second argument.">"_⊆_"</code>.</p>

<p>So why does this all matter?  Invariably all programming languages have to deal with the question, <em>"can you do x with y?"</em>.  Just as in everyday life, it only makes sense to perform certain actions with certain things.  For example, I can <me>ride</em> a bike, but it would be silly to try to <em>ride</em> a scone.  The bike is a vehicle, the  scone is a food (if it is proven someday that a scone is in fact a vehicle, I will change this example).  If you sat on a scone and tried to ride it, first off you wouldn't go anywhere. After not having gone anywhere, when you got up, what remained of the scone would not resemble a scone.  Now it isn't that the bike "understands" the concept of being ridden and the scone does not, it is the fact that the bike and the scone have observably different properties that gives us clues on how we can interact with them.  A bike has wheels, pedals, and a seat, so let's ride it!  A scone contains nutrition, it is tasty, and it is digestible, so let's eat it!  Hell, let's get on that bike and ride it while we eat our scone!  This of course isn't advised, especially while drinking hot tea, but the intrinsic qualities of these things will permit us to attempt such an operation.</p>

<p>Of course there exists internal sensibilities that keeps us from sitting on that scone or chomping on that bike.  These sensibilities have been developed through years of life experience and interacting with the things around us (or just a good friend who tells you, <em>"dude, don't eat that bike"</em>).  It is the context of what we presently know that helps us categorize new things along side things with which we are already familiar.  Thus we are able to confidently apply the sorts of operations we know to be compatible with similarly categorized things to said new thing.  In this way, we develop our own type system for life.</p>

<p>Some programming languages replicate this <em>life context</em> in the form of a <a class="offsite" href="https://en.wikipedia.org/wiki/Compiler">compiler</a>.  Not only does a  compiler have the ability to translate your program into instructions the computer can understand, it also can have the potential to tell you if you've set up your instructions in such a way that, when run, could possibly lead to someone attempting to consume a bicycle.  A language that does this for you is in some part <b>type-safe</b>.  At a high level, the degree of type-safety in a programming language is measured by how effective the language is at keeping you from permitting an unintended operation on a type with which the operation is not compatible.</p>

<p>I can continue to go on about this at length as there is much more to be said.  However, I indicated that this post was not about providing a full treatment on types, but instead to give an overview that will help in understanding Avail as well as the content of my posts.  Naturally, this leads us into a conversation about the Avail type system, which will set us up nicely to discuss <a href="/content/semantic-restrictions">semantic restrictions</a>.  So marinade on this for a few days, and I will hopefully have another post coming out soon.</p>

<p><em><b>UPDATE 1/23/2013</b><br>
NOTE: I'd be remiss not to mention the fact that the Avail type system does not support user customizable predicate types such as even numbers or prime numbers.  It is impossible to determine the equality of the range of two different functions that, in theory, produce the same results.  Therefore it cannot be determined in general that two different, yet equivalent functions used as predicates for a type, are equal types.  The examples provided above, though not applicable in the Avail type system, were used because they are fairly straightforward making the presented material more tractable for the concept it was conveying.</em></p>