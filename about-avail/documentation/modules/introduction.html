---
---
<!doctype html>
<html lang="en-US">
	<head>

{% include head.html %}

		<title>Modules - Introduction</title>

	</head>

	<body class="gradient-logo">

{% include body-top.html %}

<h2 class="content-title">Introduction</h2>

<p>An Avail program &mdash; be it a system, library, or application &mdash; comprises a collection of modules. A <strong>module</strong> is a container for Avail code. These statements are loose enough to be true, in different ways, at both compile time and run time.</p>

<p>At <a class="offsite" href="https://en.wikipedia.org/wiki/Compile_time">compile time</a>, the compiler operates on an Avail program as a collection of source modules<sup><a href="#fn1">[1]</a></sup>. A <strong>source module</strong> is a human-readable document that describes, sincerely, a variety of types, values, and operations. It is generally a creative work produced by a programmer, though it might be the output of a code generator. A valid source module is a <a class="offsite" href="https://en.wikipedia.org/wiki/Plain_text">plain text</a> document that contains <a class="offsite" href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> <a class="offsite" href="https://en.wikipedia.org/wiki/Code_point">code points</a> in the <a class="offsite" href="https://en.wikipedia.org/wiki/Utf-8">UTF-8</a> <a class="offsite" href="https://en.wikipedia.org/wiki/Character_encoding">character encoding</a>. A source module that resides within a file system must have a <code>.avail</code> file extension.</p>

<p>At <a class="offsite" href="https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase)">run time</a>, the executor operates on an Avail program only as a collection of binary modules. A <strong>binary module</strong> is the output of the Avail compiler, and is not intended to be human-readable. Its purpose is to improve the performance of executing Avail code. The separation of Avail code into source and binary forms also permits developers to distribute their software without having to also distribute their source code. This flexibility is essential to many software business models.</p>

<p>Throughout this series, when the term "module" is used without a qualifier, like "source" or "binary", then it will refer exclusively to a source module. If the discussion regards a binary module, then the term "binary module" will be used explicitly. This simplification of nomenclature is made because the primary purpose of this series is to explain the features of modules from the perspective of an Avail programmer, who deals primarily with source modules.</p>

<p>Whether in source or binary form, a module has three primary responsibilities:</p>

<ul>
<li>To declare its dependencies, so that a human or machine reader can understand its relationship to upstream modules.</li>
<li>To define services, in the form of methods, that may be consumed by downstream modules.</li>
<li>To define services, in the form of entry points, that may be consumed by <a class="offsite" href="https://en.wikipedia.org/wiki/End_user">end users</a> and external programs.</li>
</ul>

<div style="float: right;" class="floating-svg-wrapper">

	<img src="/images/modules/upstream-downstream.svg" alt="module graph demonstrating upstream/downstream relationship">

</div>

<p>A module <code class="module">A</code> is <strong>upstream</strong> of a module <code class="module">B</code> if <code class="module">A</code> must be compiled before <code class="module">B</code> can be compiled. A module <code class="module">C</code> is <strong>downstream</strong> of a module <code class="module">D</code> if <code class="module">C</code> cannot be compiled until <code class="module">D</code> has been compiled. So upstream and downstream are reciprocal relationships based on the notion of <strong>module dependency</strong>: a module depends upon another (upstream) module, directly or indirectly, if it consumes services made available by that module.</p>

<p style="clear: both">A module is divided into two main units:</p>

<ul>
<li>The <strong>module header</strong>, which declares the services that the module consumes and the services that it provides for consumption.</li>
<li>The <strong>module body</strong>, which defines the services that it provides for consumption.</li>
</ul>

<p>We will begin by examining the module header.</p>

<hr/>

<p><small><a id="fn1">[1]</a> Actually, the compiler operates also on binary modules produced by previous compilations. This dramatically improves the performance of the build process, but has no impact on the semantics of compilation. Using a hybrid source-binary module compilation approach is isomorphic to using a source-only approach, so we will discuss the process in terms of the latter only, for simplicity.</small></p>

<table class="book-nav">
	<tr>
		<td class="book-nav-up"><a class="book-nav-up" href="./index.html">Return to Modules</a></td>
		<td class="book-nav-spacer">|</td>
		<td class="book-nav-forward"><a class="book-nav-forward" href="./module-headers.html">Module Headers â€º</a></td>
	</tr>
</table>

{% include body-bottom.html %}

	</body>

</html>
