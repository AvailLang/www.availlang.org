<!doctype html>
<!--[if lt IE 7]> <html class="ie6 oldie"> <![endif]-->
<!--[if IE 7]>    <html class="ie7 oldie"> <![endif]-->
<!--[if IE 8]>    <html class="ie8 oldie"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="">
<!--<![endif]-->

	<head>
	
<!--#include virtual="/_include/head.ssi" -->

		<title>Modules - Name Resolution</title>

	</head>

	<body class="gradient-logo">
	
<!--#include virtual="/_include/body-top.ssi" -->
		
<h2 class="content-title">Name Resolution</h2>

<img src="/_images/modules/import-export-intersection.png" alt="A Venn diagram showing 'Extends' as the intersection of 'Uses' and 'Names'." style="float: right; width: 33%"/>

<p>Names are the concurrency of modules, freely exchanged across boundaries. Names flow into modules through <a href="./private-imports-section.html">private imports</a> and <a href="./extended-imports-section.html">extend imports</a> sections. Names flow out of modules through <a href="./introduced-names-section.html">introduced names</a> and extended imports sections.</p>

<p>Every name is associated with an <a href="/about-avail/documentation/type-system/types-atom.html">atom</a> that is created at the point of the name's original introduction. There are only two ways to introduce a name:</p>

<ol>
<li>By mentioning the name, as a <a href="/about-avail/documentation/type-system/types-string.html">string literal</a>, in an introduced names section.</li>
<li>By sending <code class="method">"atom for_"</code> (or a <a class="offsite" href="http://en.wikipedia.org/wiki/Delegation_(programming)">delegate</a> like <code class="method">"$&hellip;"</code>) to a string that represents the name. This only introduces the name if it was not imported or mentioned in the sending module's introduced names section. All names introduced in this fashion are private to the sending module (unless explicitly exported with <code class="method">"Export_as a new name"</code>).</li>
</ol>

<p>Think of an atom as a discrete particle of identity. Most values in Avail are identityless, so atoms are interesting just by dint of having identity. As such, it is occasionally useful to resolve a name to an atom for no other reason than to obtain the atom. It is more often the case, however, that a dependent module imports a name because it wishes to use the associated method in its <a href="./module-bodies.html">body</a>.</p>

<p>There are two ways to reference a name within a module body:</p>

<ol>
<li>By sending a message that resolves a name to an atom, such as <code class="method">"Method_is_"</code>, to a string that represents a name.</li>
<li>By using the name to send a message. In this case, the compiler parses the source text to identify the names that correspond to expressions. For example, the compiler discovers as a consequence of parsing that <code>1 + 3</code> corresponds to a send of <code class="method">"_+_"</code>.</li>
</ol>

<table class="book-nav">
	<tr>
		<td class="book-nav-back"><a class="book-nav-back" href="./module-bodies.html">‹ Module Resolution</a></td>
		<td class="book-nav-spacer">|</td>
		<td class="book-nav-up"><a class="book-nav-up" href="./index.html">Return to Modules</a></td>
		<td class="book-nav-spacer">|</td>
		<td class="book-nav-forward"><a class="book-nav-forward" href="./feature-visibility.html">Name Resolution ›</a></td>
	</tr>
</table>

<!--#include virtual="/_include/body-bottom.ssi" -->

	</body>

</html>
