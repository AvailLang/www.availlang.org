<!doctype html>
<!--[if lt IE 7]> <html class="ie6 oldie"> <![endif]-->
<!--[if IE 7]>    <html class="ie7 oldie"> <![endif]-->
<!--[if IE 8]>    <html class="ie8 oldie"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="">
<!--<![endif]-->

	<head>
	
<!--#include virtual="/_include/head.ssi" -->
	
		<title>The Avail Workbench</title>
	
	</head>

	<body class="gradient-logo">
	
<!--#include virtual="/_include/body-top.ssi" -->

		<h2 class="content-title">The Avail Workbench</h2>

<p>		
Now that you've <a href="something">downloaded, installed, configured, and opened</a> the Avail workbench, let's take a tour!
</p>
<h3>Tour of the workbench</h3>
<a href="/_images/documentation/workbench/fresh-workbench.png" title="View image at full resolution."><img class="full-line-screenshot" src="/_images/documentation/workbench/fresh-workbench.png" width=820 alt="A screenshot of the Avail workbench."></a>
<p>
The workbench has five main sections:
<ol>
	<li>The modules pane</li>
	<li>The entry points pane</li>
	<li>The text input field</li>
	<li>The transcript pane</li>
	<li>The menu bar</li>
</ol>
</p><p>
<h4>1. The modules pane</h4>
<a href="/_images/documentation/workbench/modules-pane.png" title="View image at full resolution."><img class="top-right-screenshot" src="/_images/documentation/workbench/modules-pane.png" width=232 align="right" alt="The workbench screenshot, cropped to show only the modules pane. Selected module roots and packages have been expanded or collapsed to show variety."></a>
Recall from the <a href="something">installation <code class="module">README</code></a> that the Avail workbench depends on the <code>AVAIL_ROOTS</code> environment variable for the <strong>root</strong> directories where Avail libraries may be found. If this variable is not explicitly set before the workbench is opened, the default roots <code>avail</code> and <code>examples</code> will be used. <code>avail</code> is the root of the standard library, which contains all of the functionality needed to program in Avail. Accordingly, this root must always be present. <code>examples</code> contains smallish programs that demonstrate various uses of Avail. This includes the source modules for all of the <a href="/about-avail/learn/index.html">tutorials</a> featured on the website.
</p><p>
Regardless of how they are specified, roots show up in the workbench modules pane as top-level, collapsible entities, and are arranged in the order that they were specified. As top-level entities of hierarchical structures, they are left-justified within the pane. Each root name is bolded, and the display visibility of each root's contents can be toggled by clicking on the triangle to the left of the root name.
</p><p>
Every time it starts up, the workbench determines the contents of each root by recursively exploring its corresponding directory. Within a root directory, all file names that end with <code>.avail</code> are considered, regardless of their actual content, to be Avail <strong>modules</strong> named by whatever precedes this extension. Files without this extension are ignored. Similarly, all directory names that end with <code>.avail</code> are considered to be Avail module <strong>packages</strong>, and all other directories and their contents are ignored. Within each root and package, there may be any number of modules and packages. They are displayed in the modules pane in lexicographic order. Module names appear to the right of a <code>.avail</code> file icon (<img src="/_images/download-icons/avail.png" alt="module" width="24" height="24">), and packages appear to the right of a the Avail package icon, which looks like a folder (<img src="/_images/documentation/workbench/package.png" alt="package" width="24" height="24">).
</p><p>
The Avail compiler requires that each package directory contain an identically-named file, just inside, to function as the package representative module. Realistically, this representative <em>is</em> the package, because it encapsulates the component modules and provides a common interface for their public functionality. But to preserve hierarchical structuring in the filesystem, we must use directories. Since the workbench is focused on Avail's structure, and not the filesystem's structure, it provides access to the package through the package name. Accordingly, the representative module is not listed as a subordinate, and because of the structural nature of the scan, it does not even require its presence. So, beware! A directory that doesn't actually include a representative module will display as a package, but the package will fail to compile. We'll get to compilation after we're done with the tour.
</p><p>
<h4>2. The entry points pane</h4>
<a href="/_images/documentation/workbench/entry-points-pane.png" title="View image at full resolution."><img class="top-right-screenshot" src="/_images/documentation/workbench/entry-points-pane.png" width=233 align="right" alt="The workbench screenshot, cropped to show only the entry points pane. Selected entry point modules have been expanded or collapsed to show variety."></a>
After the workbench finishes scanning for all accessible <code>.avail</code> files and directories within its roots, it invokes the Avail compiler in a limited "header-scanning" mode. The compiler goes through all of the <code>.avail</code> files found, interpreting the information in its <code>Uses</code>, <code>Extends</code>, <code>Names</code>, and <code>Entries</code> sections in order to build the roots' dependency graphs. Whenever any module included anywhere on the dependency graph specifies a method in its <code>Entries</code> section, it is being marked as an Avail entry point. The method name and path are stored into a list, and that list is the source of information for the workbench's entry points pane.
</p><p>
Though entry points may occur at any depth within their own package hierarchy, entry points are Avail's equivalent of the classic <code>main()</code> method: each is a top-level program. So instead of displaying entry points hierarchically, they are instead grouped by their source module's full path. These path headings are displayed in bold and arranged in lexicographic order. The display visibility of a path's entry points can be toggled by clicking on the triangle to the left of the path. When visible, entry points common to a single path are displayed slightly indented below their path heading, and are listed in lexicographic order. 
</p><p>
<h4>3. The text input field</h4>
<a href="/_images/documentation/workbench/text-entry-field.png" title="View image at full resolution."><img class="top-right-screenshot" src="/_images/documentation/workbench/text-entry-field.png" width=294 align="right" alt="The workbench screenshot, cropped to show only the left side of the empty and inactive text input field."></a>
There's not much to say about the initial appearance of the text input field. When the workbench is opened, it will be empty and have a grey background. Just above it is the label "Command:".
</p><p>
Yup. There it is, just sitting there, waiting for you to breathe life into it!
<h4>4. The transcript pane</h4>
<a href="/_images/documentation/workbench/transcript-pane.png" title="View image at full resolution."><img class="top-right-screenshot" src="/_images/documentation/workbench/transcript-pane.png" width=291 align="right" alt="The workbench screenshot, cropped to show only a small portion of the empty transcript pane."></a>
In the transcript pane, you get to see the fruits of our collective labors! The text output of running processes, as well as the echo of any user input, will be displayed here in a fixed-width font. Specifically,
<ul>
	<li>Standard output text is displayed in <code><span style="color:black">black</span></code>.</li>
	<li>Standard error text is displayed in <code><span style="color:red">red</span></code>.</li>
	<li>Informational messages are displayed in <code><span style="color:blue">blue</span></code>.</li>
	<li>Commands, a.k.a. sends of entry points, are echoed in <code><span style="color:magenta">magenta</span></code>.</li>
	<li>User input to active entry points is echoed in <code><span style="color:green">green</span></code>.</li>
</ul>
</p><p>
<h4>4. The menu bar</h4>
This section will be only a brief description of the menus and their features. During your exploration, note that many of the menu commands have keyboard shortcuts associated with them.
<ul>
	<li>
		<h5>avail-dev</h5>
		This menu only appears on MacOS systems, and most of its content is OS-supplied. The one customized menu item it has is:
		<ul>
			<li><strong>About avail-dev</strong>: Open the About window, which contains a link to the Avail website, the versions of Avail supported by the workbench instance, and the copyright notice. In non-Mac systems, this menu item appears in the Build menu.</li>
		</ul>
	</li>
	<li>
		<h5>Build</h5>
		This menu offers commands for building modules listed in the modules pane and managing the binaries that have already been compiled to the repository and/or loaded into memory:
		<ul>
			<li><strong>Build</strong>: Initiate a build process for the selected module. If the binary version of the module does not already exist in the repository, or if the source file has been modified and does not have a matching binary in the repository, a new binary is created using the module's source file. The builder then ensures the binary is loaded into memory. Building is disabled when no module is selected. <em>This command also appears in the modules pane and entry points pane context menus.</em></li>
			<li><strong>Cancel Build</strong>: Cancel the build process that is underway. This command is disabled when no build is active.</li>
			<li><strong>Unload</strong>: Unload the selected module's binaries from memory, forcing them to be reloaded from the repository the next time they are required. Targeted unloading is disabled when no module with a binary loaded into memory is selected. <em>This command also appears in the modules pane context menu.</em></li>
			<li><strong>Unload All</strong>: Unload all of the binaries in memory.</li>
			<li><strong>Clean All</strong>: Unload all of the binaries in memory and delete all binary modules from the repository.</li>
			<li><strong>Refresh</strong>: Forces the workbench to re-orient itself with respect to all source files. The <code>avail_roots</code> environment variable will be read, the roots will be explored, and the module headers will be scanned again. The roots and modules in the modules pane and the entry points in the entry points pane will all be refreshed. <em>This command also appears in the modules pane and entry points pane context menus.</em></li>
		</ul>
	</li>
	<li>
		<h5>Document</h5>
		This menu offers commands for generating documentation for modules using the in-source Availdoc documentation, e.g. API documentation in the Stacks format:
		<ul>
			<li><strong>Generate Documentation</strong>: Initiate documentation generation for the selected modules. Documentation generation is disabled when no modules are selected. <em>This command also appears in the modules pane context menu.</em></li>
			<li><strong>Set Documentation Path</strong>: Specify the local filesystem path where generated documentation should be deposited.</li>
		</ul>
	</li>
	<li>
		<h5>Run</h5>
		This menu offers commands for interacting with the workbench:
		<ul>
			<li><strong>Insert Entry Point</strong>: Insert the text invocation of the selected entry point into the text entry field. The argument positions of the method, represented with underscores in the method names, will remain, and must be filled with arguments in order for the command to be successful. Entry point insertion is disabled when no entry point is selected. <em>This command also appears in the entry points pane context menu.</em></li>
			<li><strong>Clear Transcript</strong>: Remove all content from the transcript pane. <em>This command also appears in the transcript pane context menu.</em></li>
		</ul>
	</li>
</ul>
</p><p>
<h3>Putting the "work" in workbench</h3>
Now, to make it go.
</p><p>
In order for the workbench to actually do anything other than sit there looking pretty, you, dear user, will need to interact with it! But I bet that's what you've been waiting for.
</p><p>
The workbench serves two essential functions: Avail developers can use it to assist in module debugging and testing, and users can run Avail programs by entering commands.
</p>
<h2>This is as far as I've gotten.</h2>

Notes for further content: 

modules are compiled and loaded from the independent modules on down, in parallel

Issues when two modules write to the same global state fields without doing proper synchronization.

when a build is started, get a global progressbar above the transcript window. When done, it disappears and blue "Done (TIMEs)."

When a module is built, the builder traverses the dependency graph down to its leaf nodes: the modules which have no dependencies. These modules are compiled

looks to find all entry points from loaded modules, builds synthetic module to import contents from  each loaded modules with an entry point and pastes your invocation in as code, then runs it. If only 1 module comes back with a successful interpretation, it runs it. If more than one comes back OK, the compiler rejects the send as ambiguous. If none come back, 

Can’t use entry point at an argument position unless the entry point’s module exports that entry point as a method.

<!--#include virtual="/_include/body-bottom.ssi" -->

	</body>

</html>
