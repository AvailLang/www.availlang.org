[
	{	
		"name" : "all indices of_where_",
		"implementations" : [
			{
				"methodDescription" : "Compute and answer the indices of all the elements of `aTuple` that satisfies the specified predicate.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple to search"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that accepts the elements of the tuple."}
				],
				"return" : {"type" : "<natural number…|0..∞>", "description" : "The indices of all the satisfactory elements of the predicate."}
			}	
		]
	},
	{	
		"name" : "all indices of_in_",
		"implementations" : [
			{
				"methodDescription" : "Compute and answer the indices of all the elements of `aTuple` that satisfies the specified predicate.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple to search for the subtuple"},
					{"param" : "subtuple", "type" : "<natural number…|>", "description" : "The subtuple to locate in aTuple."}
				],
				"return" : {"type" : "<natural number…|>", "description" : "A tuple of the indices of the start of every instance of subtuple, <> if none"}
			}	
		]		
	},
	{	
		"name" : "distinct_",
		"implementations" : [
			{
				"methodDescription" : "Compute and answer the distinct elements of `aTuple`, preserving order.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple being acted on"}
					],
				"return" : {"type" : "<natural number…|>", "description" : "A tuple that contains only the distinct elements of `aTuple`, and in the order in which they were encountered."}
			}	
		]
	},
	{	
		"name" : "drop from_until_",
		"implementations" : [
			{
				"methodDescription" : "Compute and answer the suffix of `aTuple` that begins with the element that answers `true` to `predicate`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple being acted on"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that can accept each element of the specified tuple. It should answer `false` to discard the element (and continue scanning) or `true` to abort."}
				],
				"return" : {"type" : "tuple", "description" : "The requested suffix."}
			}
		]
	},
	{	
		"name" : "drop from_while_",
				"implementations" : [
			{
				"methodDescription" : "Compute and answer the suffix of `aTuple` that begins with the element that answers `false` to `predicate`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple being acted on"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that can accept each element of the specified tuple. It should answer `true` to discard the element (and continue scanning) or `false` to abort."}
				],
				"return" : {"type" : "tuple", "description" : "The requested suffix."}
			}
		]
	},
	{	
		"name" : "drop_from_",
		"implementations" : [
			{
				"methodDescription" : "Answer a tuple containing every element of `aTuple` except for the first `count` elements.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "count", "whole number" : "tuple", "description" : "The size of the prefix of `aTuple` that should be omitted from the result tuple."},
					{"param" : "aTuple", "type" : "tuple", "description" : "The source tuple."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple containing every element but the first `count` elements of `aTuple`, preserving the original order."}
			}
		]
	},
	{	
		"name" : "first index of_in_",
		"implementations" : [
			{
				"methodDescription" : "Obtain the location of the start of the first occuring subtuple in a tuple (a substring of a string).  This is the abstract implementation.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple within which to search for the subtuple."},
					{"param" : "subtuple", "tuple" : "tuple", "description" : "The subtuple to locate in aTuple."}
				],
				"return" : {"type" : "whole number", "description" : "The index of the start of the first subtuple, 0 if none."}
			}
		]
	},
	{	
		"name" : "replace the first occurrence of_in_with_",
		"implementations" : [
			{
				"methodDescription" : "Locate of the first instance of a nonempty subtuple occuring in a nonempty tuple and replace it with the new replacement tuple (replace a substring with a new substring).",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "subtuple", "type" : "tuple", "description" : "The subtuple to locate in aTuple."},
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple to search for the subtuple"},
					{"param" : "replacementTuple", "type" : "tuple", "description" : "The tuple to swap out all subtuples with"}
				],
				"return" : {"type" : "whole number", "description" : "the new tuple with the first occurrence of the subtuple replaced with the replacement tuple"}
			}
		]
	},
	{	
		"name" : "merge sort_with_",
		"implementations" : [
			{
				"methodDescription" : "Construct and answer a sorted variant of aTuple using the merge sort algorithm and specified comparison function.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple to sort."},
					{"param" : "comparator", "type" : "[⊥, ⊥]→boolean", "description" : "A comparison function that accepts two elements of aTuple and answers true if the first ≤ second and false otherwise."}
				],
				"return" : {"type" : "tuple", "description" : "The sorted tuple"}
			}
		]
	},
	{	
		"name" : "merge sort_",
		"implementations" : [
			{
				"methodDescription" : "Construct and answer a sorted variant of aTuple of numbers using the merge sort algorithm, where n ≤ m.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "<number…|>", "description" : "The tuple to sort."}
				],
				"return" : {"type" : "<number…|>", "description" : "the sorted tuple"}
			}
		]
	},
	{	
		"name" : "_[_.._]else_",
		"implementations" : 
		[
			{
				"methodDescription" : "If start and end are valid subscripts representing a valid range for aTuple, then answer the corresponding element. Otherwise, answer the result obtained by applying else.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : 
				[
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "start", "type" : "integer", "description" : "An integer"},
					{"param" : "end", "type" : "integer", "description" : "An integer"},
					{"param" : "else", "type" : "[]→any", "description" : "The function to apply if start through end is not a valid range of aTuple."}
				],
				"return" : {"type" : "any", "description" : "The start-th throught the end-th elements of  aTuple, or the result of applying else (if index is invalid)."}
			}
		]
	},
	{	
		"name" : "For each of⁇_do_",
		"implementations" : [
			{
				"methodDescription" : "Iteratively apply `action` to each consecutive element of `aTuple`.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "action", "type" : "[⊥]→⊤", "description" : "A function that accepts the elements of the tuple."}
				],
				"return" : {"type" : "⊤", "description" : "none"}
			},
			{
				"methodDescription" : "Iteratively apply `action` to each consecutive element of `aTuple`.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "action", "type" : "⊥, ⊥]→⊤", "description" : "A function that accepts 1) an element of the tuple and 2) the index of that element."}
				],
				"return" : {"type" : "⊤", "description" : "none"}
			}
		]
	},
	{
		"name" : "first index of_where_",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer the index of the first element of `aTuple` that satisfies the specified predicate.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple to search"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that accepts the elements of the tuple."}
				],
				"return" : {"type" : "whole number", "description" : "The index of the first satisfactory element, or 0 if no element satisfied the predicate."}
			}
		]
	},
	{
		"name" : "last index of_where_",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer the index of the last element of `aTuple` that satisfies the specified predicate.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "The tuple to search"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that accepts the elements of the tuple."}
				],
				"return" : {"type" : "whole number", "description" : "The index of the last satisfactory element, or 0 if no element satisfied the predicate."}
			}
		]
	},
	{
		"name" : "left fold_through_",
 		"implementations" : [
			{
				"methodDescription" : "Reduce `aTuple` via the binary function, traversing the tuple from left to right. Answer the result of the reduction.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "<any…|1..>", "description" : "A nonempty tuple."},
					{"param" : "transformer", "type" : "[⊥, ⊥]→any", "description" : "A binary function whose second parameter type matches its return type. The first parameter type must be general enough to accept each element of `aTuple`."}
				],
				"return" : {"type" : "any", "description" : "The only element of `aTuple` if `aTuple` contains only one element. Otherwise, the result of iteratively applying `transformer` to 1) the left-to-right consecutive elements of `aTuple` and 2) the previous results of applying `transformer`."}
			}
		]
	},
	{
		"name" : "quicksort_",
 		"implementations" : [
			{
				"methodDescription" : "Construct and answer a sorted variant of numbers using the quicksort algorithm. When overriding 'quicksort_', only target tuple types that contain at least two elements. Not only do the trivial cases of 0 and 1 elements have a simple universal implementation, the 0-element (i.e., empty tuple) case causes ambiguous resolution if multiple overrides exist that will accept it.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "numbers", "type" : "<number…|>", "description" : "A tuple of numbers."}
				],
				"return" : {"type" : "<number…|>", "description" : "A tuple of numbers in ascending order."}
			}
		]
	},
	{
		"name" : "quicksort_with_",
 		"implementations" : [
			{
				"methodDescription" : "Construct and answer a sorted variant of aTuple using the quicksort algorithm and specified comparison function.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple."},
					{"param" : "comparator", "type" : "[⊥, ⊥]→boolean",  "description" : "A comparison function that accepts two elements of aTuple and answers true if the first ≤ second and false otherwise."}
				],
				"return" : {"type" : "tuple", "description" : "A sorted variant of aTuple."}
			}
		]
	},
	{
		"name" : "right fold_through_",
 		"implementations" : [
			{
				"methodDescription" : "Reduce `aTuple` via the binary function, traversing the tuple from right to left. Answer the result of the reduction.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "<any…|1..>", "description" : "A nonempty tuple."},
					{"param" : "transformer", "type" : "[⊥, ⊥]→any",  "description" : "A binary function whose second parameter type matches its return type. The first parameter type must be general enough to accept each element of `aTuple`."}
				],
				"return" : {"type" : "any", "description" : "The only element of `aTuple` if `aTuple` contains only one element. Otherwise, the result of iteratively applying `transformer` to 1) the right-to-left consecutive elements of `aTuple` and 2) the previous results of applying `transformer`."}
			}
		]
	},
	{
		"name" : "split_after_",
 		"implementations" : [
			{
				"methodDescription" : "Split a `aTuple` into two tuples between `pivot` and `pivot + 1` and answer a 2-tuple containing the results.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple."},
					{"param" : "pivot", "type" : "whole number",  "description" : "The index (inclusive) at which to split `aTuple`."}
				],
				"return" : {"type" : "<tuple…|2>", "description" : "A 2-tuple. The first tuple contains the first `pivot` elements of `aTuple`. The second tuple contains the remaining elements of `aTuple`."}
			}
		]
	},
	{
		"name" : "split_before_",
 		"implementations" : [
			{
				"methodDescription" : "Split a `aTuple` into two tuples between `pivot` and `pivot + 1` and answer a 2-tuple containing the results.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple."},
					{"param" : "pivot", "type" : "whole number",  "description" : "The index (exclusive) at which to split `aTuple`."}
				],
				"return" : {"type" : "<tuple…|2>", "description" : "A 2-tuple. The first tuple contains the first `pivot` elements of `aTuple`. The second tuple contains the remaining elements of `aTuple`."}
			},
			{
				"methodDescription" : "Split a `aTuple` into two tuples",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple."},
					{"param" : "predicate", "type" : "[⊥]→boolean",  "description" : "A function that accepts each element of the tuple. It must answer `true` when the pivot position has been reached. The function will not be applied again answer it has answered `true`."}
				],
				"return" : {"type" : "<tuple…|2>", "description" : "A 2-tuple. The first tuple contains the elements of `aTuple` to which `predicate` was applied. The second tuple contains the remaining elements of `aTuple`."}
			}
		]
	},
	{
		"name" : "stripe_at_",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer the specified stripe of `aTuple`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "<<any…|1..>…|>", "description" : "A tuple of non-empty tuples."},
					{"param" : "index", "type" : "natural number",  "description" : "The stripe index."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple comprising the `index`-th elements of each element of `aTuple`."}
			}
		]
	},
	{
		"name" : "take from_until_",
 		"implementations" : [
			{
				"methodDescription" : "Answer a tuple containing the prefix of `aTuple` that answered `false` to `predicate`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple."},
					{"param" : "predicate", "type" : "[⊥]→boolean",  "description" : "A function that can accept each element of the specified tuple. It should answer `false` to keep the element (and continue scanning) or `true` to abort."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple containing the prefix of `aTuple` that satisfied `predicate`."}
			}
		]
	},
	{
		"name" : "take from_while_",
 		"implementations" : [
			{
				"methodDescription" : "Answer a tuple containing the prefix of `aTuple` that answered `true` to `predicate`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple."},
					{"param" : "predicate", "type" : "[⊥]→boolean",  "description" : "A function that can accept each element of the specified tuple. It should answer `true` to keep the element (and continue scanning) or `false` to abort."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple containing the prefix of `aTuple` that satisfied `predicate`."}
			}
		]
	},
	{
		"name" : "take_from_",
 		"implementations" : [
			{
				"methodDescription" : "Answer a tuple containing the first `count` elements of `aTuple`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "count", "type" : "whole number", "description" : "The size of the requested tuple."},
					{"param" : "aTuple", "type" : "tuple", "description" : "The source tuple."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple containing the first `count` elements of `aTuple`, preserving the original order."}
			}
		]
	},
	{
		"name" : "zip_",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer the zip of the specified tuples. Given N input tuples, the output is the tuple whose i-th element contains the i-th element from each consecutive input tuple. The size of the output equals to the smallest size of the inputs. Each of the output's tuples has length equal to the number of inputs.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "tuples", "type" : "<tuple…|1..>", "description" : "A tuple of tuples."}
				],
				"return" : {"type" : "tuple", "description" : "The zip of the input tuples."}
			}
		]
	},
	{
		"name" : "«_‡zip»",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer the zip of the specified tuples. Given N input tuples, the output is the tuple whose i-th element contains the i-th element from each consecutive input tuple. The size of the output equals to the smallest size of the inputs. Each of the output's tuples has length equal to the number of inputs.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "tuples", "type" : "<tuple…|1..>", "description" : "A tuple of tuples."}
				],
				"return" : {"type" : "tuple", "description" : "The zip of the input tuples."}
			}
		]
	},
	{
		"name" : "∑_",
 		"implementations" : [
			{
				"methodDescription" : "Sum the elements of the specified tuple of integers.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "intTuple", "type" : "<extended integer…|1..∞>", "description" : "A tuple of integers."}
				],
				"return" : {"type" : "extended integer", "description" : "An integer"}
			}
		]
	},
	{
		"name" : "∏_",
 		"implementations" : [
			{
				"methodDescription" : "Take the product of the elements of a tuple of integers.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "intTuple", "type" : "<extended integer…|1..∞>", "description" : "A tuple of integers."}
				],
				"return" : {"type" : "extended integer", "description" : "An integer"}
			}
		]
	},
	{
		"name" : "_ends with_",
 		"implementations" : [
			{
				"methodDescription" : "Does `aTuple` end with the subsequence `suffix`?",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "Tuple", "description" : "The tuple whose suffix should be checked against `suffix`."},
					{"param" : "suffix", "type" : "tuple", "description" : "The search tuple."}
				],
				"return" : {"type" : "boolean", "description" : "`true` if `aTuple` ends with the subsequence `suffix`, `false` otherwise."}
			}
		]
	},
	{
		"name" : "“_”",
 		"implementations" : [
			{
				"methodDescription" : "Produce a description of the argument. The default implementation uses `primitive description of_` to obtain a mechanically constructed description from the Avail virtual machine. Overrides should provide semantic information that is appropriately localized for the default locale.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "t", "type" : "tuple meta", "description" : "a type of tuple"}
				],
				"return" : {"type" : "string", "description" : "A description of the argument."}
			}
		]
	},
	{
		"name" : "_occurrences⁇of_",
 		"implementations" : [
			{
				"methodDescription" : "Construct and answer a tuple whose elements are each `value`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "count", "type" : "whole number", "description" : "The number of elements in the resulting tuple."},
					{"param" : "value", "type" : "any", "description" : "The repeated value."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple containing `count` occurrences of `value`."}
			}
		]
	},
	{
		"name" : "_to_",
 		"implementations" : [
			{
				"methodDescription" : "Construct and answer a tuple that contains the consecutive integers from `start` (inclusive) up to `end` (inclusive), counting up by 1. If `end < start`, then answer the empty tuple.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "start", "type" : "integer", "description" : "The first value of the resulting tuple."},
					{"param" : "end", "type" : "integer", "description" : "The last value of the resulting tuple."}
				],
				"return" : {"type" : "<integer…|>", "description" : "The interval from `start` (inclusive) up to `end` (inclusive)."}
			},
			{
				"methodDescription" : "Construct and answer a string that contains the consecutive characters from `start` (inclusive) to `end` (inclusive). If `start's code point ≤ end's code point`, then `result[i]'s code point < result[i+1]'s code point`; otherwise, `result[i]'s code point > result[i+1]'s code point`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "start", "type" : "integer", "description" : "The first value of the resulting tuple."},
					{"param" : "end", "type" : "integer", "description" : "The last value of the resulting tuple."}
				],
				"return" : {"type" : "<character…|>", "description" : "The interval from `start` (inclusive) up to `end` (inclusive)."}
			}
		]
	},
	{
		"name" : "count of_where_",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer the count of elements of `aTuple` that satisfy the given predicate.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that accepts the elements of the tuple and answers `true` if the element should be represented in the resulting count."}
				],
				"return" : {"type" : "whole number", "description" : "Compute and answer the count of elements (and indices) of `aTuple` that satisfy the given predicate."}
			},
			{
				"methodDescription" : "Construct and answer a string that contains the consecutive characters from `start` (inclusive) to `end` (inclusive). If `start's code point ≤ end's code point`, then `result[i]'s code point < result[i+1]'s code point`; otherwise, `result[i]'s code point > result[i+1]'s code point`.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "predicate", "type" : "[⊥, ⊥]→boolean", "description" : "A function that accepts 1) an element of the tuple and 2) the index of that element and answers `true` if the element should be represented in the resulting count."}
				],
				"return" : {"type" : "whole number", "description" : "The number of elements of `aTuple` for which `predicate` answers `true`."}
			}
		]
	},
	{
		"name" : "each of_satisfies_",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer whether each of the elements of `aTuple` satisfies the specified function. Do not examine more elements than necessary.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that accepts the elements of the tuple and answers a boolean."}
				],
				"return" : {"type" : "boolean", "description" : "`true` if `predicate` answers `true` for each element of `aTuple`, `false` otherwise."}
			},
			{
				"methodDescription" : "Compute and answer whether each of the elements (and indices) of `aTuple` satisfy the specified function. Do not examine more elements than necessary.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "predicate", "type" : "[⊥, ⊥]→boolean", "description" : "A function that accepts 1) an element of the tuple and 2) the index of that element and answers a boolean."}
				],
				"return" : {"type" : "boolean", "description" : "`true` if `predicate` answers `true` for each element of `aTuple`, `false` otherwise."}
			}
		]
	},
	{
		"name" : "any of_satisfies_",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer whether any of the elements of `aTuple` satisfies the specified function. Do not examine more elements than necessary.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that accepts the elements of the tuple and answers a boolean."}
				],
				"return" : {"type" : "boolean", "description" : "`true` if `predicate` answers `true` for any element of `aTuple`, `false` otherwise."}
			},
			{
				"methodDescription" : "Compute and answer whether any of the elements (and indices) of `aTuple` satisfy the specified function. Do not examine more elements than necessary.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "predicate", "type" : "[⊥, ⊥]→boolean", "description" : "A function that accepts 1) an element of the tuple and 2) the index of that element."}
				],
				"return" : {"type" : "boolean", "description" : "`true` if `predicate` answers `true` for any element of `aTuple`, `false` otherwise."}
			}
		]
	},
	{
		"name" : "map and filter_by_",
 		"implementations" : [
			{
				"methodDescription" : "Iteratively apply `accumulator` to the consecutive elements and indices of `aTuple` in order to transform and filter its elements into a new tuple. When `accumulator` is invoked, it is passed a 'keeper' function. The keeper function may be invoked to 'save' a particular value, i.e., a value that will be copied into the output tuple. The keeper function will save at most one value per element of `aTuple`, i.e., each time that `accumulator` is invoked, it may invoke the keeper function at most one time. Answer the new tuple.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "accumulator", "type" : "[⊥, ⊥, ⊥]→⊤", "description" : "A function that accepts 1) an element from `aTuple`, 2) the index of that element, and 3) a keeper function. The keeper function accepts an argument of the type that should be saved."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple whose elements are those saved by the `accumulator`."}
			},
			{
				"methodDescription" : "Iteratively apply `accumulator` to the consecutive elements of `aTuple` in order to transform and filter its elements into a new tuple. When `accumulator` is invoked, it is passed a 'keeper' function. The keeper function may be invoked to 'save' a particular value, i.e., a value that will be copied into the output tuple. The keeper function will save at most one value per element of `aTuple`, i.e., each time that `accumulator` is invoked, it may invoke the keeper function at most one time. Answer the new tuple.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "accumulator", "type" : "[⊥, ⊥]→⊤", "description" : "A function that accepts 1) an element from `aTuple` and 2) a keeper function. The keeper function accepts an argument of the type that should be saved."}
				],
				"return" : {"type" : "boolean", "description" : "A tuple whose elements are those saved by the `accumulator`."}
			}
		]
	},
	{
		"name" : "filter_by_",
 		"implementations" : [
			{
				"methodDescription" : "Iteratively apply `predicate` to each consecutive element of `aTuple`, collecting those elements for which `predicate` answers `true` into a new tuple (and preserving ordering). Answer the new tuple.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "predicate", "type" : "[⊥]→boolean", "description" : "A function that accepts the elements of the tuple and answers `true` iff they should be accumulated into the output tuple."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple containing exactly those elements of `aTuple` for which `predicate` answered `true`."}
			},
			{
				"methodDescription" : "Iteratively apply `predicate` to each consecutive element and index of `aTuple`, collecting those elements for which `predicate` answers `true` into a new tuple (and preserving ordering). Answer the new tuple.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "predicate", "type" : "[⊥, ⊥]→boolean", "description" : "A function that accepts 1) an element of the tuple and 2) the index of that element and which answers `true` iff the elements should be accumulated into the output tuple."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple containing exactly those elements of `aTuple` for which `predicate` answered `true`."}
			}
		]
	},
	{
		"name" : "map_through_",
 		"implementations" : [
			{
				"methodDescription" : "Iteratively apply `transformer` to each consecutive element of `aTuple`, collecting the results into a new tuple (and preserving ordering of the transformed elements). Answer this tuple.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "transformer", "type" : "[⊥]→any", "description" : "A function that accepts the elements of the tuple."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple of results of applications of `transformer` to the elements of `aTuple`."}
			},
			{
				"methodDescription" : "Iteratively apply `transformer` to each consecutive element of `aTuple`, collecting the results into a new tuple (and preserving ordering of the transformed elements). Answer this tuple.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "transformer", "type" : "[⊥, ⊥]→any", "description" : "A function that accepts 1) an element of the tuple and 2) the index of that element."}
				],
				"return" : {"type" : "tuple", "description" : "A tuple of results of applications of `transformer` to the elements and indices of `aTuple`."}
			}
		]
	},
	{
		"name" : "Require:_accepts_",
 		"implementations" : [
			{
				"methodDescription" : "Helper method for semantic restrictions: If `action` does not accept the type union of all element types of `tupleType` and their indices, then reject the current parse.",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "action", "type" : "function meta", "description" : "A function type whose first parameter must correspond to the type union of the element types of `tupleType` and whose second parameter, if provided, must correspond to `indices`."},
					{"param" : "tupleType", "type" : "tuple meta", "description" : "A tuple type"}
				],
				"return" : {"type" : "⊤", "description" : "none"}
			}
		]
	},
	{
		"name" : "_is empty",
 		"implementations" : [
			{
				"methodDescription" : "Is the specified tuple empty?",
				"category" : "Collections",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"}
				],
				"return" : {"type" : "boolean", "description" : "`true` if the argument is empty, `false` otherwise."}
			}
		]
	},
	{
		"name" : "_'s⁇head",
 		"implementations" : [
			{
				"methodDescription" : "Obtain the first element of the specified tuple.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "<any…|1..>", "description" : "A nonempty tuple"}
				],
				"return" : {"type" : "any", "description" : "The first element of `aTuple`."}
			}
		]
	},
	{
		"name" : "_'s⁇tail",
 		"implementations" : [
			{
				"methodDescription" : "Construct and answer a tuple slice that contains all but the first element of the specified tuple. If the argument contains only one element, then answer an empty tuple.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "<any…|1..>", "description" : "A nonempty tuple"}
				],
				"return" : {"type" : "tuple", "description" : "The requested tuple slice."}
			}
		]
	},
	{
		"name" : "_'s⁇last",
 		"implementations" : [
			{
				"methodDescription" : "Obtain the last element of the specified tuple.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "<any…|1..>", "description" : "A nonempty tuple"}
				],
				"return" : {"type" : "any", "description" : "The last element of a `aTuple`."}
			}
		]
	},
	{
		"name" : "_[.._]else_",
 		"implementations" : [
			{
				"methodDescription" : "If 'end' is a valid subscript representing the end of a valid range for'aTuple', then answer the corresponding element. Otherwise, answer the result obtained by applying 'else'.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "end", "type" : "integer", "description" : "An integer"},
					{"param" : "else", "type" : "[]→any", "description" : "The function to apply if 1 through 'end' is not a valid range of 'aTuple"}
				],
				"return" : {"type" : "any", "description" : "The first through the 'end'-th elements of 'aTuple', or the result of applying 'else' (if 'end' is invalid)."}
			}
		]
	},
	{
		"name" : "_[_..]else_",
 		"implementations" : [
			{
				"methodDescription" : "If 'start' is a valid subscripts representing a valid range for 'aTuple', then answer the corresponding element. Otherwise, answer the result obtained by applying 'else'.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "start", "type" : "integer", "description" : "An integer"},
					{"param" : "else", "type" : "[]→any", "description" : "The function to apply if 'start' through the end of aTuple is not a valid range of 'aTuple"}
				],
				"return" : {"type" : "any", "description" : "The 'start'-th throught the last elements of 'aTuple', or the result of applying 'else' (if 'start' is invalid)."}
			}
		]
	},
	{
		"name" : "_[_.._]→_",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer a tuple that is the result of replacing the specified slice of `aTuple` with `replacement`.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "sliceStart", "type" : "natural number", "description" : "The subscript of the first element of the target slice."},
					{"param" : "sliceEnd", "type" : "whole number", "description" : "The subscript of the last element of the target slice."},
					{"param" : "replacement", "type" : "tuple", "description" : "The tuple that should be spliced into `aTuple` instead of the specified slice."}
				],
				"return" : {"type" : "tuple", "description" : "A variant of `aTuple` whose elements from `sliceStart` (inclusive) to `sliceEnd` (inclusive) have been replaced with those of `replacement`. Elements before `sliceStart` and after `sliceEnd`  will be present in the answer."}
			}
		]
	},
	{
		"name" : "_[_↔_]",
 		"implementations" : [
			{
				"methodDescription" : "Compute and answer that is the result of swapping the elements of 'aTuple' at 'index1' and 'index2'.",
				"category" : "Tuples",
				"module" : "Tuples.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "index1", "type" : "natural number", "description" : "A subscript"},
					{"param" : "index2", "type" : "natural number", "description" : "A subscript"}
				],
				"return" : {"type" : "tuple", "description" : "A variant of 'aTuple' whose elements at indices 'index1' and 'index2' have been exchanged. No other elements are affected."}
			}
		]
	},
	{
		"name" : "_[_]",
 		"implementations" : [
			{
				"methodDescription" : "Answer the `index`-th element of `aTuple`.",
				"category" : "Tuples",
				"module" : "Fallible Primitives.avail",
				"parameters" : [
					{"param" : "aTuple", "type" : "tuple", "description" : "A tuple"},
					{"param" : "index", "type" : "natural number", "description" : "The one-based index of the desired element."}
				],
				"return" : {"type" : "tuple", "description" : "The requested element."}
			}
		]
	}
]
