<!doctype html>
<!--[if lt IE 7]> <html class="ie6 oldie"> <![endif]-->
<!--[if IE 7]>    <html class="ie7 oldie"> <![endif]-->
<!--[if IE 8]>    <html class="ie8 oldie"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="">
<!--<![endif]-->

	<head>
	
<!--#include virtual="/_include/head.ssi" -->
	
		<title>The Avail Workbench</title>
	
	</head>

	<body class="gradient-logo">
	
<!--#include virtual="/_include/body-top.ssi" -->

		<h2 class="content-title">The Avail Workbench</h2>

<p>		
Now that you've <a href="/about-avail/download/index.html">downloaded, installed, configured, and opened</a> the Avail workbench, let's take a tour!
</p>
<h3>Tour of the workbench</h3>
<a href="/_images/documentation/workbench/fresh-workbench.png" title="View image at full resolution."><img class="full-line-screenshot" src="/_images/documentation/workbench/fresh-workbench.png" width=820 alt="A screenshot of the Avail workbench."></a>
<p>
The workbench has five main sections:
<ol>
	<li>The modules pane</li>
	<li>The entry points pane</li>
	<li>The text input field</li>
	<li>The transcript pane</li>
	<li>The menu bar</li>
</ol>
</p><p>
<h4>1. The modules pane</h4>
<a href="/_images/documentation/workbench/modules-pane.png" title="View image at full resolution."><img class="top-right-screenshot" src="/_images/documentation/workbench/modules-pane.png" width=232 align="right" alt="The workbench screenshot, cropped to show only the modules pane. Selected module roots and packages have been expanded or collapsed to show variety."></a>
Recall from the installation <code class="module">README</code> that the Avail workbench depends on the <code>AVAIL_ROOTS</code> environment variable for the <strong>root</strong> directories where Avail libraries may be found. If this variable is not explicitly set before the workbench is opened, the default roots <code>avail</code> and <code>examples</code> will be used. <code>avail</code> is the root of the standard library, which contains all of the functionality needed to program in Avail. Accordingly, this root must always be present. <code>examples</code> contains smallish programs that demonstrate various uses of Avail. This includes the source modules for all of the <a href="/about-avail/learn/index.html">tutorials</a> featured on the website.
</p><p>
Regardless of how they are specified, roots show up in the workbench modules pane as top-level, collapsible entities, and are arranged in the order that they were specified. As top-level entities of hierarchical structures, they are left-justified within the pane. Each root name is bolded, and the display visibility of each root's contents can be toggled by clicking on the triangle to the left of the root name.
</p><p>
Every time it starts up, the workbench determines the contents of each root by recursively exploring its corresponding directory. Within a root directory, all file names that end with <code>.avail</code> are considered, regardless of their actual content, to be Avail <strong>modules</strong> named by whatever precedes this extension. Files without this extension are ignored. Similarly, all directory names that end with <code>.avail</code> are considered to be Avail module <strong>packages</strong>, and all other directories and their contents are ignored. Within each root and package, there may be any number of modules and packages. They are displayed in the modules pane in lexicographic order. Module names appear to the right of a <code>.avail</code> file icon (<img src="/_images/download-icons/avail.png" alt="module" width="24" height="24">), and packages appear to the right of a the Avail package icon, which looks like a folder (<img src="/_images/documentation/workbench/package.png" alt="package" width="24" height="24">).
</p><p>
The Avail compiler requires that each package directory contain an identically-named file, just inside, to function as the package representative module. Realistically, this representative <em>is</em> the package, because it encapsulates the component modules and provides a common interface for their public functionality. But to preserve hierarchical structuring in the filesystem, we must use directories. Since the workbench is focused on Avail's structure, and not the filesystem's structure, it provides access to the package through the package name. Accordingly, the representative module is not listed as a subordinate, and because of the structural nature of the scan, it does not even require its presence. So, beware! A directory that doesn't actually include a representative module will display as a package, but the package will fail to compile. We'll get to compilation after we're done with the tour.
</p><p>
<h4>2. The entry points pane</h4>
<a href="/_images/documentation/workbench/entry-points-pane.png" title="View image at full resolution."><img class="top-right-screenshot" src="/_images/documentation/workbench/entry-points-pane.png" width=233 align="right" alt="The workbench screenshot, cropped to show only the entry points pane. Selected entry point modules have been expanded or collapsed to show variety."></a>
After the workbench finishes scanning for all accessible <code>.avail</code> files and directories within its roots, it invokes the Avail compiler in a limited "header-scanning" mode. The compiler goes through all of the <code>.avail</code> files found, interpreting the information in its <code>Uses</code>, <code>Extends</code>, <code>Names</code>, and <code>Entries</code> sections in order to build the roots' dependency graphs. Whenever any module included anywhere on the dependency graph specifies a method in its <code>Entries</code> section, it is being marked as an Avail entry point. The method name and path are stored into a list, and that list is the source of information for the workbench's entry points pane.
</p><p>
Though entry points may occur at any depth within their own package hierarchy, entry points are Avail's equivalent of the classic <code>main()</code> method: each is a top-level program. So instead of displaying entry points hierarchically, they are instead grouped by their source module's full path. These path headings are displayed in bold and arranged in lexicographic order. The display visibility of a path's entry points can be toggled by clicking on the triangle to the left of the path. When visible, entry points common to a single path are displayed slightly indented below their path heading, and are listed in lexicographic order. 
</p><p>
<h4>3. The text input field</h4>
<a href="/_images/documentation/workbench/text-entry-field.png" title="View image at full resolution."><img class="top-right-screenshot" src="/_images/documentation/workbench/text-entry-field.png" width=294 align="right" alt="The workbench screenshot, cropped to show only the left side of the empty and inactive text input field."></a>
There's not much to say about the initial appearance of the text input field. When the workbench is opened, it will be empty and have a grey background. Just above it is the label "Command:".
</p><p>
Yup. There it is, just sitting there, waiting for you to breathe life into it!
<h4>4. The transcript pane</h4>
<a href="/_images/documentation/workbench/transcript-pane.png" title="View image at full resolution."><img class="top-right-screenshot" src="/_images/documentation/workbench/transcript-pane.png" width=291 align="right" alt="The workbench screenshot, cropped to show only a small portion of the empty transcript pane."></a>
In the transcript pane, you get to see the fruits of our collective labors! The text output of running processes, as well as the echo of any user input, will be displayed here in a fixed-width font. Specifically,
<ul>
	<li>Standard output text is displayed in <code><span style="color:black">black</span></code>.</li>
	<li>Standard error text is displayed in <code><span style="color:red">red</span></code>.</li>
	<li>Informational messages are displayed in <code><span style="color:blue">blue</span></code>.</li>
	<li>Commands, a.k.a. sends of entry points, are echoed in <code><span style="color:magenta">magenta</span></code>.</li>
	<li>User input to active entry points is echoed in <code><span style="color:green">green</span></code>.</li>
</ul>
</p><p>
<h4>4. The menu bar</h4>
This section will be only a brief description of the menus and their features. During your exploration, note that many of the menu commands have keyboard shortcuts associated with them.
<ul>
	<li>
		<h5>avail-dev</h5>
		This menu only appears on MacOS systems, and most of its content is OS-supplied. The one customized menu item it has is:
		<ul>
			<li><strong>About avail-dev</strong>: Open the About window, which contains a link to the Avail website, the versions of Avail supported by the workbench instance, and the copyright notice. In non-Mac systems, this menu item appears in the Build menu.</li>
		</ul>
	</li>
	<li>
		<h5>Build</h5>
		This menu offers commands for building modules listed in the modules pane and managing the binaries that have already been compiled to the repository and/or loaded into memory:
		<ul>
			<li><strong>Build</strong>: Initiate an activation process for the selected module. If the binary version of the module does not already exist in the repository, or if the source file has been modified and does not have a matching binary in the repository, a new binary is created by compiling the module's source file. The workbench then ensures the binary is loaded into memory. Activation is disabled when no module is selected. <em>This command also appears in the modules pane and entry points pane context menus.</em></li>
			<li><strong>Cancel Build</strong>: Cancel the activation process that is underway. This command is disabled when no activation process is active.</li>
			<li><strong>Unload</strong>: Unload the selected module's binaries from memory, forcing them to be reloaded from the repository the next time they are required. Targeted unloading is disabled when no module with a binary loaded into memory is selected. <em>This command also appears in the modules pane context menu.</em></li>
			<li><strong>Unload All</strong>: Unload all of the binaries in memory.</li>
			<li><strong>Clean All</strong>: Unload all of the binaries in memory and delete all binary modules from the repository.</li>
			<li><strong>Refresh</strong>: Forces the workbench to re-orient itself with respect to all source files. The <code>avail_roots</code> environment variable will be read, the roots will be explored, and the module headers will be scanned again. The roots and modules in the modules pane and the entry points in the entry points pane will all be refreshed. <em>This command also appears in the modules pane and entry points pane context menus.</em></li>
		</ul>
	</li>
	<li>
		<h5>Document</h5>
		This menu offers commands for generating documentation for modules using the in-source Availdoc documentation, e.g. API documentation in the Stacks format:
		<ul>
			<li><strong>Generate Documentation</strong>: Initiate documentation generation for the selected modules. Documentation generation is disabled when no modules are selected. <em>This command also appears in the modules pane context menu.</em></li>
			<li><strong>Set Documentation Path</strong>: Specify the local filesystem path where generated documentation should be deposited.</li>
		</ul>
	</li>
	<li>
		<h5>Run</h5>
		This menu offers commands for interacting with the workbench:
		<ul>
			<li><strong>Insert Entry Point</strong>: Insert the text invocation of the selected entry point into the text entry field. The argument positions of the method, represented with underscores in the method names, will remain, and must be filled with arguments in order for the command to be successful. Entry point insertion is disabled when no entry point is selected. <em>This command also appears in the entry points pane context menu.</em></li>
			<li><strong>Clear Transcript</strong>: Remove all content from the transcript pane. <em>This command also appears in the transcript pane context menu.</em></li>
		</ul>
	</li>
</ul>
</p><p>
<h3>Putting the "work" in workbench</h3>
Now, to make it go.
</p><p>
In order for the workbench to actually do anything other than sit there looking pretty, you, dear user, will need to interact with it! But I bet that's what you've been waiting for.
</p><p>
The workbench serves two essential functions: Avail developers can use it to assist in module debugging and testing, and users can run Avail programs by entering commands. In order to take part in either of these activities, at least one module must be activated. Since you have, of course, read our fabulous <a href="/about-avail/documentation/modules/index.html">documentation of modules</a>, you know all about module dependencies: in order to use any target module, all of its upstream dependencies must be processed. And because you took the tour above, you know that there is a difference between a module being compiled and a module being loaded into memory: compiled modules reside in the repository, while loaded modules are available in the workbench's program memory for use. Activation of a module in the workbench ensures that module and its ancestors are all both compiled and loaded.
</p><p>
<h4>Activating modules</h4>
The modules pane distinguishes between modules that have not yet been activated in the current workbench instance and those that have. In the tour screenshot, all of the modules appeared in grey italic text. This is because a freshly-opened workbench will have no modules active. 
</p><p>
To activate a module, and all of its upstream modules, you can do any of the following:
<ol>
	<li>Double-click the module name</li>
	<li>Right-click the module name to bring up the context menu, and then click the "Build" menu item</li>
	<li>Select the module name in the modules pane, click on the Build menu, and then click on the "Build" menu item</li>
</ol>
</p><p>
When an activation is started, the transcript will be cleared of any old text automatically. While modules are being compiled and loaded, a progress bar appears temporarily above the transcript pane to display the overall progress of activating the selected module and all of its ancestors. Relatively quick progress over a module or group of modules may indicate that there was already a binary available in the repository. Slower progress means either that the module binary was not present in the repository or that it is exceptionally large.
</p><p>
Avail modules are essentially directions to the Avail runtime. For example, module declarations and definitions tell the runtime to recognize and take meaning from certain specific text and syntax. Modules can also make the runtime do something, as opposed to learning something: print statements. Because the compilation of source modules and the loading of binary modules involves the runtime processing the directives in those modules, print statement output is displayed in the transcript pane in <code><span style="color:black">standard output text</span></code> while modules are being compiled or loaded. The Avail standard library does not contain any print-to-standard-out statements, and such side-effects are highly discouraged in finished products; however, using temporary print statements to help you debug your code can be very advantageous.
</p><p>
Once a module activates successfully, i.e. without any compilation or dependency resolution errors, its name becomes un-italicized and turns from grey to black. After the full activation process is complete, the progress bar disappears and the transcript window displays the informational message <code><span style="color:blue">Done (###s).</span></code> where ### is the total activation process time in seconds. 
</p><p>
<h4>Debugging</h4>
When there is an error in the compilation of your target module or one of its ancestors, the progress bar will disappear and the transcript pane will display, in <code><span style="color:red">standard error text</span></code>, a code snippet of the offending module source followed by a veritable <a class="offsite" href="http://en.wikipedia.org/wiki/Sm%C3%B6rg%C3%A5sbord">smörgåsbord</a> of suggestions about what you might have done wrong. When the target module has ancestors, it's likely that at least one of them compiled and activated successfully. So while your buggy module and all of its descendants will remain grey, italic, and sad, the buggy module's ancestors may be standing proud. When you've made a change and are hopeful it will result in successful compilation, or at least want to see what it does wrong now, try activating the buggy module or any module downstream from it. Remember: any new activation request will clear the previous transcript contents, so don't try to activate something until after you are certain you can live with never seeing the current contents of the transcript pane again.
</p><p>
<h4>Activating and using entry points</h4>
You may notice that, as a result of activating a module, one or more entry points also become active. Whenever a module containing any entry points is activated, its entry points are too. Conversely, attempting to activate any entry point in a single module and activating the module path within the entry points pane both trigger an activation attempt on that module. If the attempt succeeds, all entry points in the same module will be activated.
</p><p>
The end state of the workbench is the same regardless of whether a module was activated in the modules pane or the entry points pane. However, when an activation request is targeted on a single entry point, either by double-clicking the entry point name or selecting the "Insert Entry Point" menu option, the workbench assumes you are intending to use it! While the activation is in progress, the text input field is cleared and populated with the desired entry point name. The field remains disabled while the activation is in progress.
</p><p>
When the activation attempt has completed, either successfully or unsuccessfully, the field becomes writable. If the activation failed, the text remains in the field, but any attempt to use it will only lead to heartbreak. Go back and debug, my friend.
</p><p>
On the other hand, if it was successful, congratulations! If the entry point requires any arguments, as indicated by the underscore "blanks", the first blank will be selected for ease of completion.
</p><p>
A semantically correct send of an entry point, AKA a command requires that:
<ul>
	<li>The entry point is activated.</li>
	<li>The entry point name is in the text input field, and all argument blanks have been replaced with arguments.</li>
	<li>The supplied arguments are semantically correct for the message.</li>
	<li>The cursor is in the text input field, and the Enter key is pressed!</li> 
</ul>
</p><p>
Unlike activation attempts, commands do <em>not</em> clear the existing contents of the transcript. Instead, new text is appended. (If you would like to clear the transcript, you can always do so manually.) Your command is echoed to the next line of the transcript in <code><span style="color:magenta">magenta</span></code>. Text output produced by the entry point produced is <code><span style="color:black">black</span></code>. While your entry point is running, the text entry field background is green, indicating that any text submitted is interpreted as input to the running process, and your input text is echoed to the transcript in <code><span style="color:green">green</span></code>. If the entry point you invoked runs and finishes quickly without requiring user input, you might not even see the field's background color change.
</p><p>
If your command was not semantically correct, the workbench transcript will be appended with an error-text message saying that it failed to parse. When you enter a command, the workbench is able to leverage the full flexibility of Avail syntax. However, if there was no satisfactory match between what you entered and an existing entry point, it attempts to provide you help by parsing your command from left to right, counting the number of token matches between your command and each entry point, and displaying advisory messages about the entry points tied for highest match count. This means if there are no matches between the first token of your command and the active entry points, it will list them all.
</p><p>
<h3>That's all (for now), folks!</h3>
Now that you know every nook and cranny of the Avail workbench, go give it a spin! Try running an entry point created in one of our <a href="/about-avail/learn/index.html">tutorials</a>. Or read about the <a href="/about-avail/documentation/availuator.html">Availuator</a> expression evaluator entry point, and discover the mappings of common computer science concepts on to Avail by reading the <a href="/about-avail/documentation/expression-cookbook.html">expression cookbook</a>.
</p>

<table class="book-nav">
	<tr>
		<td class="book-nav-up"><a class="book-nav-up" href="index.html">Return to Documentation</a></td>
	</tr>
</table>

<!--#include virtual="/_include/body-bottom.ssi" -->

	</body>

</html>
