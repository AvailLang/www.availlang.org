---
---
<!doctype html>
<html lang="en-US">
<head>

{% include head.html %}

		<title>Avail - Introduction</title>

	</head>

	<body class="gradient-logo">

{% include body-top.html %}

<h2 class="content-title">Introduction to Avail</h2>

<p>
Avail is a high-level computer programming language designed and developed by Mark van Gulik and Todd Smith. Mark began designing Avail in the early 80’s. Mark began implementing Avail in 1993 using Smalltalk. Mark hybridized the Smalltalk implementation with C++ in the late 90’s. Mark and Todd ported Avail to Java in 2010.
</p><p>
The name "Avail" began as an acronym meaning "Advanced Value and Identity Language". Though this phrase is still as appropriate as ever it was, nowadays the name stands on its own.
</p>

<h3>Features</h3>
<p><em>Section under construction</em></p>

<h3>Rationale</h3>
<p>
Why should you choose Avail for your future projects? There are many programming languages already. Software engineers, like all other tradespersons, want to invest their time effectively into strategies, tools, and techniques that will accelerate their craft and enable them to realize what they can imagine. Think of the former aspect as the journey and the latter as the destination. Like any other tool, a new programming language is compelling if and only if it improves the quality of the journey or the quality of the destination. Avail aims to accomplish both goals simultaneously: programming with Avail is generally simpler and more fun than programming with other languages, plus it leads almost inevitably to higher quality products.
</p><p>
Avail exists at the crossroads where the love of programming meets the disappointment that most software engineers feel toward the existing generations of tools and techniques available to their trade. Mechanical engineers enjoy the benefit of thousands of years of improvement to their tools and techniques. Software engineers, on the other hand, are a relatively new breed, and their tools are correspondingly young and untempered. Their field has received much attention from both academia and business since its inception, but the formidable constraints of hardware, finance, time, and politics have imposed many compromises on the quality of tools and techniques that could be designed, developed, and leveraged.
</p><p>
Avail has reaped the benefits of nearly two decades of freedom to conceive and create without the scheduling pressures and compromises typically imposed by third parties. Yet Avail is not rudderless. It has steered and sailed firmly toward unwavering goals and has kept its eyes on the prize.
</p>

<h3>Goals</h3>
<p>
<h4>To make programming accessible to a broader range of trades, cultures, and personalities.</h4>
Everyone knows at least a few algorithms. While the average person might not know quicksort, they know rote, formulaic procedures to accomplish their common tasks. Moreover, they are able to describe these algorithms using their native tongue well enough that another person can execute them.
</p><p>
<div class="text-highlight">∴ <em>Avail should allow a programmer to use at least a pidgin of natural language in order to express algorithms and concepts.</em></div>
</p><p>
It is undesirable, however, to sacrifice well-established domain specific languages, such as mathematics, by forcing the universal use of natural language on a programmer. As anyone who remembers mathematical word problems from primary school can attest, it is generally easier to understand mathematical scenarios when they are described in the standard symbolic notation. Obviously at least token support for the formal language of mathematics is a sine qua non for any serious programming language.
</p><p>
But there are many other formal languages in practical use; every other programming language, for instance! Plus there are indubitably many other formal languages that will yet be developed to satisfy important niches in diverse industries, fields of study, hobbies, etc. Rather than provide special support for the formal language of mathematics, it is far better to provide generalized support for building and recognizing formal languages. Then:
</p><p>
<div class="text-highlight">∴ <em>Avail should allow a programmer to devise and use domain-specific languages in order to express algorithms and concepts.</em></div>
</p><p>
In the technical literature, the phrase “natural language processing” too often means “English language processing”. It is true that English occupies an important place in the tradition of computer science and computer programming. There are, however, very many other natural languages! Lack of knowledge of the English language should not preclude a programmer from creating a program, but very often it does. Many computer science programs taught at universities around the world are presented exclusively in English, even though the native population does not use English as a first language.
</p><p>
Thus when we say “natural language”, we really mean <em>any natural language</em>, not just English. From this we conclude:
</p><p>
<div class="text-highlight">∴ <em>Avail should allow a programmer to use at least a pidgin of their own natural language in order to express algorithms and concepts.</em></div>
</p><p>
In order to accomplish this subgoal, the characters upon which natural and standard formal languages depend must be accessible to a programmer. So:
</p><p>
<div class="text-highlight">∴ <em>Avail should support the use of any <a class="offsite" href="http://unicode.org">Unicode</a> character in program source text.</em></div>
</p><p>
<h4>To make programming more capable and expressive for burgeoning and career software engineers.</h4>
Software engineers are continually thwarted by the inadequate power of expression provided by traditional programming languages. These languages come equipped with, at most, dozens of basic concepts, e.g.,
<ul>
	<li>numeric approximations</li>
	<li>arrays</li>
	<li>named records</li>
	<li>variables</li>
	<li>conditionals</li>
	<li>loops</li>
	<li>case selection</li>
	<li>named operations</li>
	<li>limited polymorphism of operations</li>
	<li>feature inheritance</li>
	<li>out-of-band exception propagation</li>
	<li>beta reduction</li>
	<li>pattern matching</li>
	<li>etc.</li>
</ul>
</p><p>
With care and cunning, a user may extend these languages, pursuant to their predefined extension strategies, e.g., by defining new classes, methods, or operators, to express perhaps a few more basic concepts. Expression of these new concepts seldom looks as good as expression of the intrinsic concepts; there is virtually always some tell that distinguishes a primitive feature from one introduced by a user. Consider this example from Java:
<div class="restricted-width-container">
<div class="neutral-code code-block">// Integer.MAX_VALUE is 2^31-1, since Java’s int has signed
// 32-bit 2’s compliment representation.
assert Integer.MAX_VALUE == 2147483647;

// Integer.MIN_VALUE is −2^31.
assert Integer.MIN_VALUE == -2147483648;

// Whoops, this overflows the 32-bit representation of integers.
// Java only provides first-order support for ℤ[2^32], i.e., the set
// of integers modulo 2^32.
final int x = Integer.MAX_VALUE + 1;
assert x == Integer.MIN_VALUE;

// Okay, so let’s use java.math.BigInteger to get the right answer.
final BigInteger bigX =
	new BigInteger(Integer.toString(Integer.MAX_VALUE))
		.add(BigInteger.ONE);

// Doesn’t look much like an arithmetic expression anymore, does it?
</div></div>
</p><p>
Natural languages, however, come equipped with, at least, tens or hundreds of thousands of ideas. They also readily permit addition of new concepts, i.e., they are deeply and intrinsically extensible. New vocabulary items are easily introduced to satisfy the demands of any particular domain. And poetry modulates even the grammar of a natural language. Extensibility is inherent in a natural language, so new constructs often parse as well as old familiar concepts.
</p><p>
From this we conclude:
</p><p>
<div class="text-highlight">∴ Avail should provide the same extensibility as a natural language so that new constructs introduced by a programmer look as natural as the primitive constructs.</div>
</p><p>
In either case, complex ideas may be realized through application and arrangement of a small number of simple ideas. Fair enough. Using a traditional programming language, however, these complex ideas are typically obscured by boilerplate and assiduous use of software patterns, i.e., stylized techniques developed to emblematically overcome limitations in a programming language’s ability to express concepts. The more such tricks must be employed to describe a particular idea, the harder the idea is to encode … and later to glean from its representation in the source text.
</p><p>
We say that any idea that is directly expressible using the primitive constructs of a programming language is <em>first-order expressible</em>. As demonstrated by the example above, integers in the range ℤ,,2147483648,, = [-2^31^, 2^31^-1], i.e. [-2147483648, 2147483647], are first-order expressible in Java. (ℤ,,2147483648,, is the finite set of integers modulo 2147483648.) This seems like a very large range … until the first time that one needs to exceed it. Even if it were a sufficiently large range for all practical purposes, it defies the natural intuition that the integers march backward and forward forever.
</p><p>
We say that any idea that is indirectly expressible using the primitive constructs of a programming language is <em>second-order expressible</em>. Sometimes we count the number of representations that an idea is removed from its usual lexical representation (in a natural language) to determine the order of expressibility. Returning to the Java example again, the integer 2147483648 is third-order expressible in Java. First it must be encoded as a string of characters, i.e., <code>java.lang.String</code>, then it must be re-encoded as an instance of the Java class <code>java.math.BigInteger</code>. Imagine then how unnatural a long arithmetic operation must appear in Java when even one term falls outside of ℤ,,2147483648,,!
</p><p>
This leads us to another conclusion:
</p><p>
<div class="text-highlight">∴ <em>Avail should provide a rich collection of primitive constructs to facilitate first-order expression of new constructs introduced by a programmer.</em></div>
</p><p>
Here is the Avail version of the example given above:
<div class="restricted-width-container">
<div class="good-code code-block">/* This declares and initializes a variable `x` whose pedantically specific
 * type is 2147483648’s type, i.e., the type whose sole instance is
 * 2147483648. `x` is initialized to the value produced by invoking the
 * method:
 *
 * “_+_” [number, number]→number
 *
 * With the values `2147483647` and `1`. Note how they correspond
 * positionally to the underscores in the method name.
 */
x : 2147483648’s type := 2147483647 + 1;
Assert: x = 2147483648;
</div></div>
</p><p>
Every engineer agrees that it is better for product developers to discover defects than for customers to do so. In software engineering, the type system of a programming language represents the first line of defense against product defects. A <em>type</em> groups values together such that they support some common protocol. It is this protocol that ultimately instills values, and therefore types, with meaning. Every <em>type system</em> serves to classify values by the protocols that they support. A type system that does no more than this is said to employ <em>dynamic typing</em>. Type systems that employ only dynamic typing defer detection of meaningless expressions until run-time, i.e. when end-users rather than software engineers will discover them. Consider this example from Smalltalk:
<div class="restricted-width-container">
<div class="bad-code code-block">goDynamicTyping
	"Here we attempt to perform a truncating divide of the dividend `42` by
	 the, uh, divisor `'Go dynamic typing!'`."
	| result |
	result := 42 // 'Go dynamic typing!';
	^result
</div></div>
</p><p>
The Smalltalk compiler does not reject this expression as nonsensical, nor attempt to provide any special reinterpretation of either term nor the operation itself in order to forcibly impose sense upon the expression. Instead the compiler happily transforms the source text into an executable method that the Smalltalk run-time environment can perform. The end-user, which hopefully will be a quality assurance person, will now discover this problem instead of the programmer who wrote this faulty method.
</p><p>
This particular case is trivial to avoid, of course. But how about this one?
<div class="restricted-width-container">
<div class="bad-code code-block">divide: dividend by: divisor
	"Perform a slightly more English-friendly truncating divide."
	| result |
	result := dividend // divisor;
	^result
</div></div>
</p><p>
Now the validity of the operation depends upon the actual values of <code>a</code> and <code>b</code> at the call site of <code>#divide:by:</code>. When this method is invoked with numeric values like <code>42</code> and <code>7</code>, then the operation is meaningful. In most other circumstances, however, the operation is not meaningful. So worse than the expression being meaningless, it is <em>occasionally meaningless</em>: it is meaningful for some operands but not others.
</p><p>
Unfortunately Smalltalk and its many dynamically typed brethren provide no facilities for annotating the type of an expression. It is our experience that all large-scale projects built upon programming languages that support only dynamic typing are riddled with occasionally meaningless expressions that must be uncovered by the repeated, meticulous application of the empirical method, i.e. testing. This leads us to another subgoal:
</p><p>
<div class="text-highlight">∴ <em>Avail should empower a programmer to reason soundly and deeply about a program without first and/or repeatedly running it.</em></div>
</p><p>
The conventional wisdom is that dynamic typing has a singular alternative: <em>static typing</em>. In programming languages that support static typing, the compiler can classify expressions by the types of values that they produce. Static typing generally means that the programmer annotates program elements like constants, variables, and operations with type information which then propagates through other program elements like expressions and statements. Some programming languages offer type inference in some or all circumstances. Type inference mechanisms use the implicit types of literals and primitive operations to deduce the types of unannotated constants, variables, and operations. In any case, good static typing automatically ascribes the strongest possible type to a particular program element that is still sufficiently general to describe all possible values of that element. The point, of course, is to enable the compiler to reject programs that are prima facie invalid because they include meaningless expressions. Type errors are found by software engineers rather than customers or even quality assurance staff. No defective artifact will be produced by the compiler; the software engineer must fix the problem and then try again.
</p><p>
So why are there still programming languages that are only dynamically typed? Because static typing is so bad in existing programming languages! It is either so weak that it unnecessarily permits meaningless programs or so strong that it unnecessarily forbids meaningful ones. The following example from Java illustrates a scenario where Java's type system is too weak to detect a meaningless expression:
<div class="restricted-width-container">
<div class="bad-code code-block">/**
 * Perform a truncating divide of the dividend by the divisor.
 * This looks innocuous enough, but remember that "int" is
 * Java's synonym for ℤ[2^32], which includes zero (0).
 *
 * @param dividend
 *        The dividend. No problem!
 * @param divisor
 *        The divisor. Note that this can actually be zero (0),
 *        which is disallowed by classical arithmetic. The
 *        actual semantic type of a Java divisor is really
 *        ℤ[2^32] \ {0}, i.e. the set of integers modulo 2^32
 *        **except for zero (0)**. Yet the type system cannot
 *        express this restricted type.
 * @returns The quotient ... except that there won't be a
 *          quotient at all if the divisor is zero (0).
 *          Instead the Java run-time will raise
 *          java.lang.ArithmeticException. Sorry about that,
 *          end-user!
 */
int divide (final int dividend, final int divisor)
{
   return divided / divisor;
}
</div></div>
</p><p>
And the following example illustrates a scenario where Java's type system is too strong to permit a meaningful expression:
</p><p>
(TODO --TLS)
</p><p>
<h3>Legacy</h3>
See the [AvailWelcome Main Wiki Page] for more (mostly outdated) information.
</p>

{% include body-bottom.html %}

	</body>

</html>

